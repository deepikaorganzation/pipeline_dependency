name: Deploy ADF Pipelines

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Choose environment to deploy'
        required: true
        default: 'Dev'
        type: choice
        options:
          - dev
          - qa
          - uat
          - prod

jobs:
  deploy-adf:
    env:
        ENV_VAR: ${{github.event.inputs.environment}}
        pipeline1: "kx-pipeline-${{github.event.inputs.environment}}-1"
        pipeline2: "kx-pipeline-${{github.event.inputs.environment}}-2"
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Install jq
        run: sudo apt-get install jq

      - name: Log in to Azure
        uses: azure/login@v2
        with:
          creds: >
                {
                  "clientId":"${{ secrets.AZURE_CLIENT_ID }}",
                  "clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}",
                  "subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}",
                  "tenantId":"${{ secrets.AZURE_TENANT_ID }}"
                }
          enable-AzPSSession: true

      - name: Deploy ADF Instance
        run: |
          az deployment group create \
            --resource-group komatsu-poc \
            --template-file main.bicep \
            --parameters adfName=komatsu-test-poc

      # - name: Extract Pipeline Order from JSON
      #   id: get_pipeline_order
      #   run: |
      #     PIPELINES=$(jq -c '.pipelines | sort_by(.dependsOn | length)' dependencies.json)
      #     echo "PIPELINES=$PIPELINES" >> $GITHUB_ENV
      #     echo $PIPELINES
      
      # - name: Deploy Pipelines in Order
      #   run: |
      #     pipelines="$PIPELINES"  # Replace with the actual environment variable or input containing the dependency JSON
      #     deployed=()
      
      #     # Function to deploy a pipeline recursively, ensuring dependencies are deployed first
      #     deploy_pipeline() {
      #       local pipeline=$1
      #       if [[ " ${deployed[@]} " =~ " $pipeline " ]]; then
      #         echo "$pipeline already deployed."
      #         return
      #       fi
      #       # Deploy dependencies first
      #       for dep in $(echo $pipelines | jq -r ".[\"$pipeline\"].dependsOn[]"); do
      #         deploy_pipeline $dep
      #       done
      #       echo "Deploying Pipeline: $pipeline..."
            
      #       # Get the pipeline name from the JSON file (ensure itâ€™s correctly extracted)
      #       pipeline_name=$(jq -r '.name' "pipeline/$pipeline.json")
            
      #       # Make sure that $pipeline_name is not empty
      #       if [ -z "$pipeline_name" ]; then
      #         echo "Error: Pipeline name is missing in pipeline/$pipeline.json"
      #         exit 1
      #       fi
      
      #       # Deploy the pipeline using the az datafactory command with the --name argument
      #       az datafactory pipeline create --factory-name komatsu-test-poc --resource-group komatsu-poc \
      #         --name "$pipeline_name" --template-file ./bicep/modules/pipeline.bicep "pipeline/$pipeline.json"
            
      #       deployed+=("$pipeline")
      #     }
      
      #     # Loop through the pipelines and deploy each one, respecting dependencies
      #     for pipeline in $(echo $pipelines | jq -r 'keys[]'); do
      #       deploy_pipeline $pipeline
      #     done
        


          # for row in $(echo "$PIPELINES" | jq -c '.[]'); do
          #   PIPELINE_NAME=$(echo "$row" | jq -r '.name')

          #   # Read and transform JSON
          #   NEW_JSON=$(jq --arg env "$ENV_VAR" '
          #     (.properties.activities[]? | select(has("typeProperties")) | .typeProperties.pipeline.referenceName)? |= 
          #       if . != null then sub("$PIPELINE_NAME"; "$pipeline1"; "g") else . end' pipeline/"$PIPELINE_NAME".json)

          #   echo "Updated JSON: $NEW_JSON"

          #   # Ensure NEW_JSON is valid JSON
          #   if [[ -z "$NEW_JSON" || "$NEW_JSON" == "null" ]]; then
          #       echo "Error: NEW_JSON is empty or invalid" >&2
          #       exit 1
          #   fi


          #   # Construct JSON object correctly
          #   pipeline=$(jq -n --argjson definition "$NEW_JSON" '
          #     [
          #       {
          #         "name": $pipeline1, 
          #         "definition": $definition
          #       }
          #     ]')

          #   echo "Final pipeline JSON: $pipeline"

          #   # Ensure pipeline is valid JSON
          #   if [[ -z "$pipeline" || "$pipeline" == "null" ]]; then
          #       echo "Error: pipeline JSON is empty or invalid" >&2
          #       exit 1
          #   fi

          #   az deployment group create \
          #     --resource-group komatsu-poc \
          #     --template-file pipeline.bicep \
          #     --parameters factoryName=komatsu-test-poc pipelines="$pipeline"
          # done


      - name: Extract Linked Service Order from JSON
        id: get_linked_service_order
        run: |
          echo "LINKED_SERVICES_DEPENDENCIES=$(jq -c '.linkedServices' dependencies.json)" >> $GITHUB_ENV
          # LINKED_SERVICES=$(jq -c '.linkedServices | sort_by(.dependsOn | length)' dependencies.json)
          # echo "LINKED_SERVICES=$LINKED_SERVICES" >> $GITHUB_ENV
          echo $LINKED_SERVICES_DEPENDENCIES

      - name: Deploy Linked Services in Order
        run: |
          linked_services="$LINKED_SERVICES_DEPENDENCIES"
          deployed=()

          deploy_linked_service() {
            local linked_service=$1
            if [[ " ${deployed[@]} " =~ " $linked_service " ]]; then
              echo "$linked_service already deployed."
              return
            fi
            
            for dep in $(echo $linked_services | jq -r ".[\"$linked_service\"][]"); do
              deploy_linked_service $dep
            done
            echo "Deploying Linked Service: $linked_service..."
            az datafactory linked-service create --factory-name komatsu-test-poc --resource-group komatsu-poc \
              --template-file ./bicep/modules/linkedService.bicep  "linkedService/$linked_service.json"
            deployed+=("$linked_service")
          }
          for linked_service in $(echo $linked_services | jq -r 'keys[]'); do
            deploy_linked_service $linked_service
          done


          # for row in $(echo "$LINKED_SERVICES" | jq -c '.[]'); do
          #   LINKED_SERVICE_NAME=$(echo "$row" | jq -r '.name')

          #   linkedServiceDefinition=$(jq -c '{properties: .properties}' linkedService/"$LINKED_SERVICE_NAME".json)
          #   # Construct JSON object correctly
          #   linkedServices=$(jq -n --arg name "$LINKED_SERVICE_NAME" --argjson definition "$linkedServiceDefinition" \
          #     '[ 
          #       {
          #         "name": $name, 
          #         "definition": $definition
          #       }
          #     ]')

          #   echo "$linkedServices"

          #   az deployment group create \
          #     --resource-group komatsu-poc \
          #     --template-file linkedService.bicep \
          #     --parameters adfName=komatsu-test-poc linkedServices="$linkedServices"
          #   done



        # for row in $(echo "$LINKED_SERVICES" | jq -c '.[]'); do
        #   LINKED_SERVICE_NAME=$(echo "$row" | jq -r '.name')
        #   # Ensure LINKED_SERVICE_NAME is not empty
        #   if [[ -z "$LINKED_SERVICE_NAME" ]]; then
        #       echo "Error: LINKED_SERVICE_NAME is empty" >&2
        #       exit 1
        #   fi
        #   echo "$LINKED_SERVICE_NAME"
        #   # Modify the name dynamically based on the environment
        #   NEW_NAME_LS=$(jq -r --arg env "$ENV_VAR" --arg linkedService "$LINKED_SERVICE_NAME"  '.name | sub("dev|qa|uat|prod"; $env; "g")' linkedService/"$LINKED_SERVICE_NAME".json)
        #   echo "$NEW_NAME_LS"
        #   # Ensure NEW_NAME_LS is not empty
        #   if [[ -z "$NEW_NAME_LS" ]]; then
        #       echo "Error: NEW_NAME_LS is empty" >&2
        #       exit 1
        #   fi

        #   # Validate and read JSON file
        #   if [[ ! -f "linkedService/$LINKED_SERVICE_NAME.json" ]]; then
        #       echo "Error: linkedService/$LINKED_SERVICE_NAME.json file does not exist" >&2
        #       exit 1
        #   fi

        #   linkedServiceDefinition=$(jq -c '{properties: .properties}' linkedService/"$LINKED_SERVICE_NAME".json)
        #   echo "$linkedServiceDefinition"
        #   # Check if JSON parsing was successful
        #   if [[ -z "$linkedServiceDefinition" || "$linkedServiceDefinition" == "null" ]]; then
        #       echo "Error: linkedServiceDefinition JSON is empty or invalid" >&2
        #       exit 1
        #   fi

        #   # Construct JSON object correctly
        #   linkedServices=$(jq -n --arg name "$NEW_NAME_LS" --argjson definition "$linkedServiceDefinition" \
        #   '[ 
        #     {
        #       "name": $name, 
        #       "definition": $definition  
        #     }
        #   ]')
        #   echo "$linkedServices"
        #   # Ensure linkedServices is valid JSON
        #   if [[ -z "$linkedServices" || "$linkedServices" == "null" ]]; then
        #       echo "Error: linkedServices JSON is empty or invalid" >&2
        #       exit 1
        #   fi

        #   echo "Deploying Linked Service: $NEW_NAME_LS"

        #   az deployment group create \
        #     --resource-group komatsu-poc \
        #     --template-file linkedService.bicep \
        #     --parameters adfName=komatsu-test-poc linkedServices="$linkedServices"
        # done
